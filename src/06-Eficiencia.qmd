---
title: "![Julia](Material/Julia.svg)"
subtitle: "Redes neuronales"
author: "David Gómez-Castro"
format:
  html:
    output-file: 06-Eficiencia-apuntes.html
  clean-revealjs:
    output-file: 06-Eficiencia-diapositivas.html
---

:::{.hidden}
```{julia}
using Pkg
Pkg.activate(".")
```
:::

# Álgebra Lineal

## *si resuelves muchas veces, factoriza tus matrices*

```{julia}
using BenchmarkTools

N = 100
A = rand(N,N)
b = ones(N)

@btime A \ b ;
```

```{julia}
using LinearAlgebra

print("Factorizar:")
@btime factorize(A)
B = factorize(A)
print("Resolver:")
@btime B \ b
@show typeof(B);
```

## Para vectores pequeños y cuyos valores no cambian usa `static array`

[`StaticArrays.jl`](https://github.com/JuliaArrays/StaticArrays.jl) 

```{julia} 
using StaticArrays, BenchmarkTools

A = [1 2 3; 4 5 6; 7 8 9]
B = @SMatrix [1 2 3; 4 5 6; 7 8 9]

@btime A^20 
@btime B^20;
```

```{julia}
#| error: true

B[3,3] = 1
```

# Cálculo paralelo

En este curso no haremos hincapié en las capacidades y técnicas de Julia para hacer cálculo en paralelo. 

Los paralelización básica puede hacerse con [`Base.Threads`](https://docs.julialang.org/en/v1/manual/multi-threading/)

Para el cálculo paralelo distribuido se cuenta con `Distributed` en la Standard Library. Véase este [Tutorial](https://docs.julialang.org/en/v1/manual/distributed-computing/).

Para cálculo paralelo en GPU hay un conjunto de paquetes llamados [JuliaGPU](https://github.com/JuliaGPU): [Cuda.jl](https://cuda.juliagpu.org/stable/), AMDGPU.jl, Metal.jl, OpenCL.jl, ...

## Threads

```{julia}
@show Threads.nthreads()
```

Si queremos fijar 20 hilo, podemos iniciar julia especificando
```{bash}
julia --threads 4
```

En Linux/MacOS podemos fijar el número de threads en .bashrc/.zshrc fijando 

```{bash}
export JULIA_NUM_THREADS=4
```

. . .

Hecho esto podemos ejecutar bucles en paralelo

```{julia}
using Base.Threads
N = 20
a = Vector{Float64}(undef, N)
@threads for i=1:N
  a[i] = i^2
end 
```

--- 

Hay que tener cuidado con los cálculos inseguros. Si tenemos más de un thread activo el siguiente código dará resultados inesperados:
```{julia}
#| eval: false
using Base.Threads
N = 1000
@show sum([ i for i = 1:N ])

s = 0
@threads for i=1:N
  global s += i  
end 
@show s;
```

## [Distributed]((https://discourse.julialang.org/t/what-is-the-difference-between-threads-spawn-and-distributed-spawnnat/35560) {.center}

# Views

# Generadores {.scrollable}

Recordamos que en `julia` podemos utilizar *list comprehension* 
```{julia}
[i for i=1:5]
```

esto es útil, por ejemplo, dentro de `sum`.

. . .

Pensando qué hace `sum`, realmente no necesitamos ocupar todo el espacio de memoria y podemos hacer evaluación `lazy`. Para esto `julia` *generadores*. En términos de sintaxis basta con decir
```{julia}
sum((i for i=1:5))
```

. . .

¿Qué objeto es este?
```{julia}
gen = (i for i=1:5)
```

. . .

Podemos convertirlo en vector
```{julia}
collect(gen)
```

. . .

El uso de generadores viene con enormes ganancias en rendimiento
```{julia}
using BenchmarkTools
N = 1_000_000
@btime sum([i for i=1:N])
@btime sum((i for i=1:N))
```

Los generadores son un tipo de `iterator`

# Iterators

Un `iterator` es una estructura`struct` y una implementación de

Required method |	Brief  description
----------------|---------------------:
`iterate(iter)` |	Returns either a tuple of the first item and initial state or nothing if empty
`iterate(iter, state)` |	Returns either a tuple of the next item and next state or nothing if no items remain

. . .

El código 
```{julia}
#| eval: false
for item in iter   # or  "for item = iter"
    # body
end
```

se traduce por 

```{julia}
#| eval: false
next = iterate(iter)
while next !== nothing
    (item, state) = next
    # body
    next = iterate(iter, state)
end
```

## Ejemplo 

Pongamos que queremos calcular $\sum_{n=0}^N n^2$ de manera eficiente. Podemos generar un iterador que genere $r^n$ iterativamente

```{julia}
mutable struct Cuadrados
  # calcularemos cuadrados hasta que n^2 > count
  count::Int 
end

# caso base
function Base.iterate(S::Cuadrados)  
  n = 1
  return n^2, n+1 # (resultado, siguiente estado)
end

# iteracion
function Base.iterate(S::Cuadrados, state)
  if state > S.count
    return nothing 
  else
    n = state
    return (n^2, n+1)
  end
end
```

```{julia}
N = 5
for m in Cuadrados(N)
  print(m, " ")
end
```

Esto está ya implementado

```{julia}
S = Cuadrados(6)
25 in S
```

--- 

Podemos simplicar el constructor, especificando el caso base como parámetro con valor por defecto
```{julia}
mutable struct Cuadrados
  count::Int # último número
end

function Base.iterate(S::Cuadrados, state=1)
  if state > S.count
    return nothing 
  else
    n = state
    return (n^2, n+1)
  end
end
```

---

Se puede usar la implementación genérica

```{julia}
@show sum(S)
```

, pero a veces es interesante dar valores precisos aprovechando fórmulas cerradas
```{julia}
function Base.sum(S::Cuadrados) 
  n = S.count 
  return n*(n+1)*(2n+1)÷6
end
```
. . . 

---

Hay que tener cuidado con algunas cuestiones. Por ejemplo
```{julia}
#| error: true
[i for i in Cuadrados(5)]
```

Falla porque `julia` quiere reservar el espacio de memoria antes de llenarlo, y necesita saber `length`

. . .

```{julia}
Base.length(S::Cuadrados) = S.count
```

ya podemos 
```{julia}
[i for i in Cuadrados(5)]
```


También podemos fijar
```{julia} 
Base.eltype(S::Type{Cuadrados}) = Int64
```


## Generators

Podemos usar una sintaxis similar a *list comprehension*, que ya tienen muchas funciones implementadas
```{julia}
x = (i^2 for i = 0:N)
sum(x)
```

## Ganancia computacional

```{julia}
N = 100_000_000
@btime sum([i^2 for i = 1:N])
@btime sum((i^2 for i = 1:N))
@btime sum(Cuadrados(N));
```

# Uso de GPUs

```{julia} 
#| eval: false 
using CUDA, BenchmarkTools
N = 10_000
A = rand(N, N);
B = CuArray(A);

@btime A * A; # 1.875 s (3 allocations: 762.94 MiB)

@time B * B; #  0.686287 seconds (1.75 M allocations: 87.821 MiB, 93.91% compilation time) 
@time B * B; # 0.000114 seconds (55 allocations: 1.250 KiB

```
