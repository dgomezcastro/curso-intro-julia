---
title: "![Julia](Material/Julia.svg)"
subtitle: "Algunos conceptos b√°sicos"
author: "David G√≥mez-Castro"

format:
    html: 
        output-file: 02-Fundamentos-apuntes.html
    clean-revealjs:
        output-file: 02-Fundamentos-diapositivas.html
---

{{< include _theme/activate.qmd >}}

# Variables

Para crear una variable, le asignamos un valor. Julia detecta por defecto elemento introducido. 

Podemos a√±adir enteros, reales, o vectores de manera sencilla

```{julia}
a = 1
```

. . .

```{julia}
@show typeof(a);
```

. . .

```{julia}
b = 1.0
```

. . .

```{julia}
@show typeof(b);
```

---

Si hacemos comparaci√≥n sencilla obtendremos que son iguales
```{julia}
a == b
```

. . .

Pero la comparaci√≥n con tipo revela que no
```{julia}
a === b
```

---

Aunque podemos especificar el tipo de float manualmente, por ejemplo un tipo float m√°s corto

```{julia}
b2 = Float32(1.0)
@show b2, typeof(b2);
```

. . .

```{julia}
b3::Float32 = 1.0
@show b3, typeof(b3);
```

. . .

Hay que ser cuidado con los valores m√°ximos

```{julia}
@show typemax(Int64);
```

. . .

El tipo `Float` incluye `Inf`, de modo que

```{julia}
@show typemax(Float64);
```

. . .

Pero tenemos una opci√≥n elegante para comprobar que

```{julia}
@show prevfloat(typemax(Float64));
```

---

Pueden darse algunos compartamiento inesperados como `integer overflow`

```{julia}
@show typemax(Int64)
@show typemax(Int64) + 1;
```

. . .

Para evitarlo se puede usar el tipo `BigInt`, que no tiene m√°ximo

Muy √∫til, por ejemplo, para

```{julia}
#| scrolled: true
@show factorial(BigInt(30));
```

. . .

Si preguntamos quien es el m√°ximo, tendremos un error

```{julia}
#| error: true
@show typemax(BigInt);
```

---

De forma similar existe el tipo `BigFloat` de n√∫meros arbitrariamente grandes. Es necesario tener cuidado pues estos n√∫meros son muy pesados de almacenar.

```{julia}
a = big(1.0)
@show typeof(a);
```

. . .

```{julia}
@show typemax(BigFloat)
@show prevfloat(typemax(BigFloat));
```

--- 

Cabe destacar que `julia` permite usar caracteres utf8 en la variables
```{julia}
Œ± = 1
```

. . .

Para escribir escribimos `\alpha` y tabulamos.

. . .

Incluso podemos usar emojis (aunque esto es claramente poco recomendable)
```{julia}
üê∂ = "Dog"
```

# L√≥gica

Podemos hacer comprobaciones l√≥gicas sencillas

```{julia}
a = 1;
b = 2;
a == b
```

```{julia}

@show a < b, a <= b, a != b;
```

## If/then/else

```{julia}
#| eval: false
if x ‚â§ 1
    x
else
    x + 1
end
```

. . .

La sintaxis `if/then/else` tiene una sintaxis abreviada
```{julia}
#| eval: false
g(n) = x ‚â§ 1 ? x : x + 1
```

. . .

```{julia}
#| eval: false
if x ‚â§ 1
    x
elseif x ‚â§ 2
    x + 1
else
    x + 2
end
```

# Bucles

En Julia podemos crear bucles de tipo `for` y `while`. 

La sintaxis `1:3` corresponde al vector `[1,2,3]`

```{julia}

for i = 1:3
    @show i
end
```

```{julia}
i = 1
while i <= 3
    @show i
    i = i + 1
end
```

---

Y hay algunos comportamientos avanzados

```{julia}
x = [4.0, 5.1, 6.0]
for (index, value) in enumerate(x)
    display("El valor de x en el √≠ndice $index es $value")
end
```


# Vectores y cadenas de texto

## Vectores y cadenas de texto

Lidiamos tambi√©n con `strings` (cadenas de cateres)

```{julia}
palabra = "hola"
@show typeof(palabra);
```

. . .

A√±adimos tambi√©n vectores

```{julia}
c = [2.1, 3.2]
```

. . .

Y accedemos a la componentes

```{julia}
c[2]
```

. . .

Esta sintaxis tambi√©n funciona con `strings`

```{julia}
palabra[3]
```

N√≥tese que el vector sabe qu√© tipo de elementos contiene

## Vectores

Podemos introducir vectores 
```{julia}
[1, 2]
```

y matrices

```{julia}
A = [1 2; 3 4]
```

. . .

No se deben confundir vectores con matrices fila

```{julia}
[1 2]
```

y matrices columna

```{julia}
reshape([1, 2], 2, 1)
```

---

En Julia los vectores son, por defecto, columnas

```{julia}
A * c
```

. . .

```{julia}

c' * A
```

. . .

Y multiplicar en sentido contrario producir√° un error

```{julia}
#| error: true
c * A
```

## Concatenaci√≥n

A diferencia de en C, se puede a√±adir elementos a un vector

```{julia}

a = [1, 2]
append!(a, 3)
```

. . .

En este caso la notaci√≥n es m√°s correcta que, por ejemplo, la notaci√≥n de MATLAB `a = [a,1]`

. . .

Usando esta notaci√≥n en Julia obtenemos lo que hemos pedimos:

```{julia}

a = [1, 2]
a = [a, 1]
```

En Julia, un vector puede contener elementos de varios tipos

--- 

Se pueden concatenar vectores con `;`

```{julia}
v = [1, 2]
[v; v]
```

. . .

N√≥tese la diferencia con

```{julia}
v = [1 2]
[v; v]
```

---

Para concatenar vectores y matrices podemos usar `hcat` y `vcat`

```{julia}
A = [1 2; 3 4]
@show hcat(A, A)
@show [A A];
```

Esta sintaxis es equivalente a `[A A]`

```{julia}
vcat(A, A)
@show [A; A]
```

## Asignaciones de vectores

Recordamos que en C, o en MATLAB, el siguiente c√≥digo 
```
int a = 1
int b = a
a = 2
```
Se queda en estado `a=2` y `b=1`

---

En Julia (y en Python) tambi√©n es as√≠ asignaciones completas tanto en escalares

```{julia}
a = 1
b = a
a = 2
@show a, b;
```
. . .

como en vectores

```{julia}
a = [1, 1]
b = a
a = [2, 1]
@show a, b;
```

---

Pero si modificamos una componente

```{julia}
a = [1, 1]
b = a
a[1] = 2
@show a, b;
```

. . .

Esto se llama "pass-by-sharing". Es el comportamiento por defecto de las funciones en Julia. [Ap√©ndice](#Ap√©ndice.-Mutabilidad-en-Julia)

. . .

Si queremos evitarlo debemos usar la opci√≥n `copy`

```{julia}
a = [1.0, 1.0]
b = copy(a)
a[1] = 2.0
@show a, b;
```

--- 

## Asignaci√≥n puntual de vectores 

```{julia}
a = [1 2]
b = [3 4]
c = b
c = a
@show b;
```

Primero compartimos b en c, y luego a en c. 

. . .

La notaci√≥n `.=` asigna puntualmente:

```{julia}
a = [1 2]
b = [3 4]
c = b
c .= a
@show b;
```

## List comprehension

Una forma muy c√≥moda de generar algunos vectores es mediante *list comprehensions* 
```{julia}
[i^2 for i in 1:3]
```

## Inicializaci√≥n de vectores

```{julia}
using BenchmarkTools
N = 1_000_000
@btime u = zeros(N)
@btime v = Vector{Float64}(undef, N);
```

# Otros tipos de datos

## Diccionarios

```{julia}
dict = Dict([("A", 1), ("B", 2)])
```

. . .

```{julia}
@show dict["A"]
```

. . .

```{julia}
Dict("A"=>1, "B"=>2)
```

## Tuplas

Las tuplas son contenedores de longitud fija e inmutables
```{julia}
a = (1, 1+1, "hello")
@show a[1]
```

. . .

```{julia}
#| error: true
a[1] = 3
```

## Definici√≥n de nuevos tipos: `struct`

Podemos definir un nuevo tipo de datos
```{julia}
struct Point
    a::Float64
    b::Float64
end

point = Point(1,2)
@show point 
@show point.a;
```

<!-- TODO: Constructores-->

## [Documentaci√≥n](https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/)

Hecha una primera introducci√≥n, es recomendable revisar la documentaci√≥n de Julia

## [Tipos abstractos y subtipos](https://docs.julialang.org/en/v1/manual/types/)

---

# Ejemplo. La sucesi√≥n de Fibonacci

## Formulaci√≥n iterativa

$$
    a_0 = 1, \qquad \qquad  a_1 = 1, \qquad \qquad a_{n} = a_{n-1} + a_{n-2}.
$$

## Con append!
```{julia}
Fib = [1,1]
N = 25
for i=1:N
    append!(Fib, Fib[end] + Fib[end-1]);
end 
Fib
```

## Con pre-alocaci√≥n
```{julia}
N = 5;
Fib = Vector{Int}(undef, N)
Fib[1] = 1
Fib[2] = 1
for n=3:N
    Fib[n] = Fib[n-1] + Fib[n-2];
end 
display(Fib)
```

## Formulaci√≥n recursiva

```{julia}
function fib(n::Integer) 
    if n ‚â§ 2 
        return 1
    else 
        return fib(n-1) + fib(n-2)
    end 
end
@show fib(5);
```

. . . 

Formulaci√≥n abreviada
```{julia}
fib(n::Integer) = n ‚â§ 2 ? one(n) : fib(n-1) + fib(n-2)
@show fib(5);
```

<!--

Adem√°s, es preferible hacer sin asignar valores 

```{julia}
#| code-fold: true
NCases = 10:20
NTests = 100
RelativeTimeLost = zeros(length(NCases))
for (case,n) in enumerate(NCases)
    for test=1:NTests
        time1 = @elapsed test = zeros(2^n);
        time2 = @elapsed test = Vector{Int}(undef, 2^n);
        RelativeTimeLost[case] += 1/NTests * time1/time2;
    end
end

using Plots
plot(NCases,RelativeTimeLost,xlabel="Vector de 2^n elementos \n ",
        ylabel="\n Tiempo fijando 0 / Tiempo sin fijar 0 ",
        label="")
```
. . .

(no es posible en MATLAB ver [documentaci√≥n](https://www.mathworks.com/help/matlab/matlab_prog/preallocating-arrays.html) )

-->

