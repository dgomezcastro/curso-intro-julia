---
title: "![Julia](Material/Julia.svg)"
subtitle: "Algunos conceptos b√°sicos"
author: "David G√≥mez-Castro"

format:
    html: 
        output-file: 02-Fundamentos-apuntes.html
    clean-revealjs:
        output-file: 02-Fundamentos-diapositivas.html
---

{{< include _theme/activate.qmd >}}

# Variables

Para crear una variable, le asignamos un valor. Julia detecta por defecto elemento introducido. 

Podemos a√±adir enteros, reales, o vectores de manera sencilla

```{julia}
a = 1
```

. . .

```{julia}
@show typeof(a);
```

. . .

```{julia}
b = 1.0
```

. . .

```{julia}
@show typeof(b);
```

---

Si hacemos comparaci√≥n sencilla obtendremos que son iguales
```{julia}
a == b 
```

. . .

Pero la comparaci√≥n con tipo revela que no
```{julia}
a === b 
```

---

Aunque podemos especificar el tipo de float manualmente, por ejemplo un tipo float m√°s corto

```{julia}
b2 = Float32(1.0)
@show b2, typeof(b2);
```

. . .

```{julia}
b3::Float32 = 1.0
@show b3, typeof(b3);
```

. . .

Hay que ser cuidado con los valores m√°ximos

```{julia}
@show typemax(Int64);
```

. . .

El tipo `Float` incluye `Inf`, de modo que

```{julia}
@show typemax(Float64);
```

. . .

Pero tenemos una opci√≥n elegante para comprobar que

```{julia}
@show prevfloat(typemax(Float64));
```

---

Pueden darse algunos compartamiento inesperados como `integer overflow`

```{julia}
@show typemax(Int64)
@show typemax(Int64) + 1;
```

. . .

Para evitarlo se puede usar el tipo `BigInt`, que no tiene m√°ximo

Muy √∫til, por ejemplo, para

```{julia}
#| scrolled: true
@show factorial(BigInt(30));
```

. . .

Si preguntamos quien es el m√°ximo, tendremos un error

```{julia}
#| error: true
@show typemax(BigInt);
```

---

De forma similar existe el tipo `BigFloat` de n√∫meros arbitrariamente grandes. Es necesario tener cuidado pues estos n√∫meros son muy pesados de almacenar.

```{julia}
a = big(1.0)
@show typeof(a);
```

. . .

```{julia}
@show typemax(BigFloat)
@show prevfloat(typemax(BigFloat));
```

--- 

Cabe destacar que `julia` permite usar caracteres utf8 en la variables
```{julia}
Œ± = 1
```

. . .

Para escribir escribimos `\alpha` y tabulamos.

. . .

Incluso podemos usar emojis (aunque esto es claramente poco recomendable)
```{julia}
üê∂ = "Dog"
```

# L√≥gica

Podemos hacer comprobaciones l√≥gicas sencillas

```{julia}
a = 1; b = 2;
a == b
```

```{julia}

@show a < b, a <= b, a != b;
```

## If/then/else

```{julia}
#| eval: false
if x ‚â§ 1 
    x 
else 
    x+1 
end
```

. . .

La sintaxis `if/then/else` tiene una sintaxis abreviada
```{julia}
#| eval: false
g(n) = x ‚â§ 1 ? x : x+1
```

. . .

```{julia}
#| eval: false
if x ‚â§ 1 
    x 
elseif x ‚â§ 2 
    x+1 
else 
    x + 2
end
```

# Bucles

En Julia podemos crear bucles de tipo `for` y `while`. 

La sintaxis `1:3` corresponde al vector `[1,2,3]`

```{julia}

for i=1:3
    @show i
end
```

```{julia}
i=1
while i<=3
    @show i
    i = i+1;
end
```

---

Y hay algunos comportamientos avanzados

```{julia}

x = [4.0,5.1,6.0]

for (index, value) in enumerate(x)
    
    display("El valor de x en el √≠ndice $index es $value")
    
end
```


# Vectores y cadenas de texto

## Vectores y cadenas de texto

Lidiamos tambi√©n con `strings` (cadenas de cateres)

```{julia}
palabra = "hola"
@show typeof(palabra);
```

. . .

A√±adimos tambi√©n vectores

```{julia}
c = [2.1,3.2]
```

. . .

Y accedemos a la componentes

```{julia}
c[2]
```

. . .

Esta sintaxis tambi√©n funciona con `strings`

```{julia}
palabra[3]
```

N√≥tese que el vector sabe qu√© tipo de elementos contiene

## Vectores

Podemos introducir vectores 
```{julia}
[1, 2]
```

y matrices

```{julia}
A = [1 2; 3 4]
```

. . .

No se deben confundir vectores con matrices fila

```{julia}
[1 2]
```

y matrices columna

```{julia}
reshape([1,2],2,1)
```

---

En Julia los vectores son, por defecto, columnas

```{julia}
A*c
```

. . .

```{julia}

c'*A
```

. . .

Y multiplicar en sentido contrario producir√° un error

```{julia}
#| error: true
c*A
```

## Concatenaci√≥n

A diferencia de en C, se puede a√±adir elementos a un vector

```{julia}

a = [1,2]
append!(a,3)
```

. . .

En este caso la notaci√≥n es m√°s correcta que, por ejemplo, la notaci√≥n de MATLAB `a = [a,1]`

. . .

Usando esta notaci√≥n en Julia obtenemos lo que hemos pedimos:

```{julia}

a = [1,2]
a = [a,1]
```

En Julia, un vector puede contener elementos de varios tipos

--- 

Se pueden concatenar vectores con `;`

```{julia}
v = [1, 2]
[v;v]
```

. . .

N√≥tese la diferencia con

```{julia}
v = [1 2]
[v;v]
```

---

Para concatenar vectores y matrices podemos usar `hcat` y `vcat`

```{julia}
A = [1 2; 3 4]
@show hcat(A, A)
@show [A A];
```

Esta sintaxis es equivalente a `[A A]`

```{julia}
vcat(A, A)
@show [A; A]
```

## Asignaciones de vectores

Recordamos que en C, o en MATLAB, el siguiente c√≥digo 
```
int a = 1
int b = a
a = 2
```
Se queda en estado `a=2` y `b=1`

---

En Julia (y en Python) tambi√©n es as√≠ asignaciones completas tanto en escalares

```{julia}
a = 1
b = a
a = 2
@show a,b;
```
. . .

como en vectores

```{julia}
a = [1, 1]
b = a
a = [2, 1]
@show a, b;
```

---

Pero si modificamos una componente

```{julia}
a = [1, 1]
b = a
a[1] = 2
@show a, b;
```

. . .

Esto se llama "pass-by-sharing". Es el comportamiento por defecto de las funciones en Julia. [Ap√©ndice](#Ap√©ndice.-Mutabilidad-en-Julia)

. . .

Si queremos evitarlo debemos usar la opci√≥n `copy`

```{julia}
a = [1.0, 1.0]
b = copy(a)
a[1] = 2.0
@show a, b;
```

--- 

## Asignaci√≥n puntual de vectores 

```{julia}
a = [1 2]
b = [3 4]
c = b
c = a
@show b;
```

Primero compartimos b en c, y luego a en c. 

. . .

La notaci√≥n `.=` asigna puntualmente:

```{julia}
a = [1 2]
b = [3 4]
c = b
c .= a
@show b;
```

## List comprehension

Una forma muy c√≥moda de generar algunos vectores es mediante *list comprehensions* 
```{julia}
[i^2 for i in 1:3]
```

## Diccionarios

```{julia}
dict = Dict([("A", 1), ("B", 2)])
```

. . .

```{julia}
@show dict["A"]
```

. . .

```{julia}
Dict("A"=>1, "B"=>2)
```

## Tuplas

Las tuplas son contenedores de longitud fija e inmutables
```{julia}
a = (1, 1+1, "hello")
@show a[1]
```

. . .

```{julia}
#| error: true
a[1] = 3
```

## Definici√≥n de nuevos tipos: `struct`

Podemos definir un nuevo tipo de datos
```{julia}
struct Point
    a::Float64
    b::Float64
end

point = Point(1,2)
@show point 
@show point.a;
```

## [Documentaci√≥n](https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/)

Hecha una primera introducci√≥n, es recomendable revisar la documentaci√≥n de Julia

## [Tipos abstractos y subtipos](https://docs.julialang.org/en/v1/manual/types/)


# Funciones

La mayor√≠a de funciones num√©ricas "habituales" viene por defecto en `julia`

```{julia}
a = 2.0;
a^2
```

. . .


```{julia}
@show sqrt(a), exp(a), sin(a);
```

---

Y todas estas funciones se pueden aplicar puntualmente a vectores o matrices, indicando que la operaci√≥n es puntual

```{julia}
v = [1, 2];
v .^ 2
```
. . .

```{julia}
@show sqrt.(v) , exp.(v) , sin.(v) ;

```

---

El usuario puede tambi√©n definir funciones. 

. . .

Bien de la manera convencional

```{julia}
function suma(x,y)
    x+y
end

suma(1,2)
```

. . .

O en l√≠nea

```{julia}
suma2(x,y) = x+y

suma2(1,2)
```

## Par√°metros opcionales (y valores por defecto)

```{julia}
function g(x ; n , m=1)
    if n==0
        return x
    else
        return x+m
    end
end 
@show g(1,n=1)
@show g(1;n=1)
@show g(1,n=1,m=2)
@show g(1;n=1,m=2);
```

## Especificar el tipo esperado

Para evitar sorpresas, podemos escribir el tipo de entrada (concreto o abstracto) en una funci√≥n
```{julia} 
function f(x::Real)
    return x^2 
end
@show f(1.0)
@show f(2)
```

. . .

```{julia}
#| error: true
f("hola")
```

## *Multiple dispatch*

Imaginemos que definimos
```{julia}
f(x::Real) = x + 1
f(x::Integer) = x + 2;
```

Como `Integer <: Real`, si ejecutado `f(2)` ¬øc√≥mo sabr√° qu√© hacer? 

. . .

Lo natural es elegir la clase "m√°s restrictiva". 
```{julia}
f(2)
```

A esto se lo conoce como *polimorfismo*. En julia podemos hacer poliformismo en todas las variables, hablamos de *multiple dispatch*.

[Un buen art√≠culo sobre esto.](https://nextjournal.com/Javierweiss/programaci√≥n-orientada-a-objetos-polimorfismo) 


# Mutabilidad en Julia

De acuerdo con la documentaci√≥n de Julia:

> Julia function arguments follow a convention sometimes called "pass-by-sharing", which means that values are not copied when they are passed to functions. Function arguments themselves act as new variable bindings (new locations that can refer to values), but the values they refer to are identical to the passed values. Modifications to mutable values (such as Arrays) made within a function will be visible to the caller. This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages. 

---

Las variables de tipo `Float` e `Int` no cambian dentro de funciones

```{julia}
function AumentarUno(a) 
    a += 1.0
    return a
end
a = 2.0
display("Primero a = $a.")
display("Calculamos AumentarUno(a) = $(AumentarUno(a))")
display("Ahora a = $a")
```

. . .

Se suele decir que Float64 es `immutable`, pues modificarlos dentro de funciones no afecta a su valor exterior

---

Los vectores y matrices, sin embargo, son `mutable`. 

. . .

Veamos en este ejemplo

```{julia}
function AumentarUnoVectorial(v) 
    v = v .+ 1
    return v
end;

v = [1,2];

@show v
@show AumentarUnoVectorial(v)
@show v;
```

. . . 

El motivo de esto es que los vectores y matrices suelen ser estructuradas pesadas, y no es recomendable copiarlas por defecto.

--- 


La convenci√≥n es a√±adir `!` al final de la funci√≥n si modifica su argumento. 

. . .

As√≠, el nombre correcto de la funci√≥n es
`AumentarUnoVectorial!`

. . .

Para evitar esta comportamiento, que es por defecto, se puede pasar una copia a la funci√≥n. Por ejemplo

. . .

```{julia}
function AumentarUnoVectorial!(v) 
    v .= v .+ 1
    return v
end;
```

. . .

```{julia}
v = [1,2]
@show v
@show AumentarUnoVectorial!(v)
@show v;
```

. . .

```{julia}
v = [1,2]
@show v
@show AumentarUnoVectorial!(copy(v))
@show v;
```

---

# Ejemplo. La sucesi√≥n de Fibonacci

## Formulaci√≥n iterativa

$$
    a_0 = 1, \qquad \qquad  a_1 = 1, \qquad \qquad a_{n} = a_{n-1} + a_{n-2}.
$$

## Con append!
```{julia}
Fib = [1,1]
N = 25
for i=1:N
    append!(Fib, Fib[end] + Fib[end-1]);
end 
Fib
```

## Con pre-alocaci√≥n
```{julia}
N = 5;
Fib = Vector{Int}(undef, N)
Fib[1] = 1
Fib[2] = 1
for n=3:N
    Fib[n] = Fib[n-1] + Fib[n-2];
end 
display(Fib)
```

## Formulaci√≥n recursive

```{julia}
function fib(n::Integer) 
    if n ‚â§ 2 
        return 1
    else 
        return fib(n-1) + fib(n-2)
    end 
end
@show fib(5);
```

. . . 

Formulaci√≥n abreviada
```{julia}
fib(n::Integer) = n ‚â§ 2 ? one(n) : fib(n-1) + fib(n-2)
@show fib(5);
```

<!--

Adem√°s, es preferible hacer sin asignar valores 

```{julia}
#| code-fold: true
NCases = 10:20
NTests = 100
RelativeTimeLost = zeros(length(NCases))
for (case,n) in enumerate(NCases)
    for test=1:NTests
        time1 = @elapsed test = zeros(2^n);
        time2 = @elapsed test = Vector{Int}(undef, 2^n);
        RelativeTimeLost[case] += 1/NTests * time1/time2;
    end
end

using Plots
plot(NCases,RelativeTimeLost,xlabel="Vector de 2^n elementos \n ",
        ylabel="\n Tiempo fijando 0 / Tiempo sin fijar 0 ",
        label="")
```
. . .

(no es posible en MATLAB ver [documentaci√≥n](https://www.mathworks.com/help/matlab/matlab_prog/preallocating-arrays.html) )

-->

# Metaprogramaci√≥n y macros

## Legado de Lisp

> The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of abstract syntax trees. In contrast, preprocessor "macro" systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful reflection capabilities are available to explore the internals of a program and its types just like any other data.

## La vida de un string

```{julia}
prog = "1 + 1"

ex1 = Meta.parse(prog)
```

```{julia}
typeof(ex1)
```

```{julia}
eval(ex1)
```

--- 

```{julia}
ex1.head
```

```{julia}
ex1.args
```

```{julia}
ex2 = Expr(:call, :+, 1, 1)
ex1 == ex2
```

## Macros

```{julia}
macro sayhello()
    return :(println("Hello, world!"))
end
```

```{julia}
@sayhello()
```

```{julia}
macro sayhello(name)
    return :(println("Hello, ", $name))
end
```

```{julia}
@sayhello("human")
```

# FIN
